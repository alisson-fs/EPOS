diff --git a/p2.txt b/p2.txt
index 1124e4e..e69de29 100644
--- a/p2.txt
+++ b/p2.txt
@@ -1,448 +0,0 @@
-diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
-index f5396db..7c5e388 100644
---- a/include/architecture/mmu.h
-+++ b/include/architecture/mmu.h
-@@ -24,6 +24,7 @@ protected:
-     static const unsigned long PAGE_SHIFT = OFFSET_BITS;
-     static const unsigned long PAGE_SIZE = 1 << PAGE_SHIFT;
-     static const unsigned long DIRECTORY_SHIFT = OFFSET_BITS + PAGE_BITS;
-+    static const unsigned long MASTER_SHIFT = DIRECTORY_SHIFT + DIRECTORY_BITS;
- 
- public:
-     // Memory page
-diff --git a/include/architecture/rv64/rv64_cpu.h b/include/architecture/rv64/rv64_cpu.h
-index d0bcf8c..6509ec1 100644
---- a/include/architecture/rv64/rv64_cpu.h
-+++ b/include/architecture/rv64/rv64_cpu.h
-@@ -212,6 +212,10 @@ public:
-     static Reg fr() { Reg r; ASM("mv %0, a0" :  "=r"(r)); return r; }
-     static void fr(Reg r) {  ASM("mv a0, %0" : : "r"(r) :); }
- 
-+    //4 + 16 + (26 - 9)
-+    static Reg pdp() { return satp() << 37; }
-+    static void pdp(Reg pdp) {satp((1UL << 63) | (pdp >> 37)); }
-+
-     static unsigned int id() { return 0; }
-     static unsigned int cores() { return 1; }
- 
-diff --git a/include/architecture/rv64/rv64_mmu.h b/include/architecture/rv64/rv64_mmu.h
-index aca12f3..968c348 100644
---- a/include/architecture/rv64/rv64_mmu.h
-+++ b/include/architecture/rv64/rv64_mmu.h
-@@ -1,16 +1,272 @@
--// EPOS RISC-V 64 MMU Mediator Declarations
-+// EPOS-- RISC-V 64 MMU Mediator Declarations
- 
--#ifndef __rv64_mmu_h
--#define __rv64_mmu_h
-+#ifndef __riscv64_mmu_h
-+#define __riscv64_mmu_h
- 
--#define __mmu_common_only__
--#include <architecture/mmu.h>
--#undef __mmu_common_only__
- #include <system/memory_map.h>
-+#include <utility/string.h>
-+#include <utility/list.h>
-+#include <utility/debug.h>
-+#include <architecture/cpu.h>
-+#include <architecture/mmu.h>
- 
- __BEGIN_SYS
- 
--class MMU: public No_MMU {};
-+class MMU: public MMU_Common<9, 9, 12>
-+{
-+    friend class CPU;
-+    friend class Setup_SifiveU;
-+
-+private:
-+    typedef Grouping_List<Log_Addr> List;
-+
-+    static const unsigned long PHY_MEM = Memory_Map::PHY_MEM;
-+
-+public:
-+    // Page Flags
-+    class RV64_Flags
-+    {
-+    public:
-+        enum {
-+            V   = 1 << 0, //Valid
-+            R   = 1 << 1, //Readable
-+            W   = 1 << 2, //Writable
-+            X   = 1 << 3, //Executable
-+            U   = 1 << 4, //User
-+            G   = 1 << 5, // Global
-+            A   = 1 << 6, //Accesed
-+            D   = 1 << 7, //Dirty
-+            CT  = 1 << 8, // Contiguous
-+            MIO  = 1 << 9, // I/O
-+            MASK = (1 << 10) - 1,
-+            APP  = (V | R | W | X),
-+            SYS  = (V | R | W | X),
-+            KC   = (V | R | X),
-+            KD   = (V | R | W),
-+            UD   = (V | R | W | U),
-+            UC   = (V | R | X | U),
-+        };
-+
-+        RV64_Flags() {}
-+        RV64_Flags(const RV64_Flags & f): _flags(f) {}
-+        RV64_Flags(unsigned int f): _flags(f) {}
-+        RV64_Flags(const Flags & f): _flags(((f & Flags::PRE)  ? V : 0) |
-+                                            ((f & Flags::RW)   ? (R | W) : R) |
-+                                            ((f & Flags::USR)  ? U : 0) |
-+                                            ((f & Flags::EX) ? X : 0)) {}
-+        operator unsigned int() const { return _flags; }
-+
-+    private:
-+        unsigned int _flags;
-+
-+    };
-+
-+    // Page_Table
-+    class Page_Table {
-+
-+    private:
-+        PT_Entry ptes[PT_ENTRIES];
-+
-+    public:
-+        Page_Table() {}
-+
-+        PT_Entry & operator[](unsigned int i) { return ptes[i]; }
-+
-+        void map(RV64_Flags flags, int from, int to) {
-+            Phy_Addr * addr = alloc(to - from);
-+            if (addr) {
-+                remap(addr, flags, from , to);
-+            } else {
-+                for(; from < to; from++){
-+                    // Log_Addr * pte = phy2log(&ptes[from]);
-+                    // *pte = phy2pte(alloc(1), flags);
-+                    ptes[from] = phy2pte(alloc(1), flags);
-+
-+                }
-+            }
-+        }
-+        void remap(Phy_Addr addr, int from, int to, RV64_Flags flags) {
-+            addr = align_page(addr);
-+            for( ; from < to; from++) {
-+                // Log_Addr * pte = phy2log(&ptes[from]);
-+                // *pte = phy2pte(addr, flags);
-+                ptes[from] = phy2pte(addr, flags);
-+                addr += sizeof(Page);
-+            }
-+        }
-+    };
-+
-+    // Chunk (for Segment)
-+    class Chunk
-+    {
-+    public:
-+        Chunk() {}
-+        // from 0 to bytes % PAGE_SIZE
-+        Chunk(unsigned int bytes, Flags flags)
-+        : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _bytes(bytes), _flags(RV64_Flags(flags)), _pt(calloc(_pts)) {
-+            _pt->map(_flags, _from, _to);
-+        }
-+
-+        ~Chunk() {
-+            for( ; _from < _to; _from++)
-+                free((*static_cast<Page_Table *>(phy2log(_pt)))[_from]);
-+            free(_pt, _pts);
-+        }
-+
-+        unsigned int pts() const { return _pts; }
-+        Page_Table * pt() const { return _pt; }
-+        unsigned int size() const { return _bytes; }
-+        int resize(unsigned int amount) { return 0; }
-+
-+    private:
-+        unsigned int _from;
-+        unsigned int _to;
-+        unsigned int _pts;
-+        unsigned int _bytes;
-+        RV64_Flags _flags;
-+        Page_Table * _pt;
-+    };
-+
-+    // Page Directory
-+    typedef Page_Table Page_Directory;
-+
-+    // Directory (for Address_Space)
-+    class Directory
-+    {
-+    public:
-+        Directory() : _pd(calloc(1)) {
-+            for(unsigned int i = 0; i < PD_ENTRIES; i++){
-+                (*_pd)[i] = (*_master)[i];
-+            }
-+        }
-+        Directory(Page_Directory * pd) : _pd(pd) {}
-+
-+        Page_Table * pd() const { return _pd; }
-+
-+        void activate() const {CPU::pdp(reinterpret_cast<CPU::Reg64>(_pd));}
-+
-+      Log_Addr attach(const Chunk & chunk, unsigned int from = 0) {
-+          for(unsigned int i = from; i < PD_ENTRIES; i++)
-+              if(attach(i, chunk.pt(), chunk.pts()))
-+                for (unsigned int j = 0; j < PD_ENTRIES; j++) {
-+                  Page_Table * chunk_pt = chunk.pt();
-+                  Page_Table * pt = reinterpret_cast<Page_Table *>((void *)(*chunk_pt)[i]);
-+                  if (attach(j, pt, chunk.pts()))
-+                    return i << MASTER_SHIFT | j << DIRECTORY_SHIFT;
-+                }
-+          return false;
-+      }
-+
-+      Log_Addr attach(const Chunk & chunk, const Log_Addr & addr) {
-+          unsigned int from = directory(addr);
-+          if(!attach(from, chunk.pt(), chunk.pts()))
-+              return Log_Addr(false);
-+          return (from << DIRECTORY_SHIFT);
-+      }
-+
-+      void detach(const Chunk & chunk) {}
-+
-+      void detach(const Chunk & chunk, Log_Addr addr) {
-+        unsigned int from = directory(addr);
-+        for (unsigned int i = from; i < PD_ENTRIES; i++) {
-+          for (unsigned int j = from; j < PD_ENTRIES; j++) {
-+            Page_Table * chunk_pt = chunk.pt();
-+            Page_Table * pt = reinterpret_cast<Page_Table *>((void *)(*chunk_pt)[i]);
-+            detach(from, pt, chunk.pts());
-+          }
-+        }
-+        detach(from, chunk.pt(), chunk.pts());
-+      }
-+
-+        Phy_Addr physical(Log_Addr addr) { return addr; }
-+
-+    private:
-+        bool attach(unsigned int from, const Page_Table * pt, unsigned int n) { //Flag
-+            for(unsigned int i = from; i < from + n; i++)
-+                if(phy2log(_pd)[i])
-+                    return false;
-+            for(unsigned int i = from; i < from + n; i++, pt++)
-+                ((phy2log(_pd)))[i] = phy2pde(Phy_Addr(pt));
-+            return true;
-+        }
-+
-+        void detach(unsigned int from, Page_Table * pt,  unsigned int n) {
-+            for (unsigned int i = from; i < from + n; i++) {
-+              (*pt)[i] = 0;
-+            }
-+        }
-+
-+    private:
-+        Page_Directory * _pd;
-+    };
-+
-+public:
-+    MMU() {}
-+
-+    static Phy_Addr alloc(unsigned int bytes = 1) {
-+        Phy_Addr phy(false);
-+        if(bytes) {
-+            List::Element * e = _free.search_decrementing(bytes);
-+            if(e)
-+                phy = reinterpret_cast<unsigned long>(e->object()) + e->size() * PAGE_SIZE;
-+            else
-+                db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
-+        }
-+        db<MMU>(TRC) << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
-+
-+        return phy;
-+    };
-+
-+    static Phy_Addr calloc(unsigned int bytes = 1) {
-+        Phy_Addr phy = alloc(bytes);
-+        memset(phy2log(phy), 0, bytes*PAGE_SIZE);
-+        return phy;
-+    }
-+
-+    static void free(Phy_Addr addr, unsigned int n = 1) {
-+        db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
-+
-+        assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
-+
-+        if(addr && n) {
-+            List::Element * e = new (addr) List::Element(addr, n);
-+            List::Element * m1, * m2;
-+            _free.insert_merging(e, &m1, &m2);
-+        }
-+    }
-+
-+    static unsigned int allocable() { return _free.head() ? _free.head()->size() : 0; }
-+
-+    static Page_Directory *volatile current()
-+    {
-+        return static_cast<Page_Directory *volatile>(phy2log(CPU::pdp()));
-+    }
-+
-+    static Phy_Addr physical(Log_Addr addr) { return addr; }
-+
-+    static void flush_tlb() { CPU::flush_tlb(); }
-+    static void flush_tlb(Log_Addr addr) { CPU::flush_tlb(addr); }
-+
-+private:
-+    static void init();
-+
-+    static Log_Addr phy2log(const Phy_Addr & phy) { return phy ; }
-+
-+    static PD_Entry phy2pde(Phy_Addr bytes) { return ((bytes >> 12) << 10) | RV64_Flags::V; }
-+
-+    static Phy_Addr pde2phy(PD_Entry entry){ return (entry & ~RV64_Flags::MASK) << 2; }
-+
-+    static PT_Entry phy2pte(Phy_Addr bytes, RV64_Flags flags) { return ((bytes >> 12) << 10) | flags; }
-+
-+    static Phy_Addr pte2phy(PT_Entry entry) { return (entry & ~RV64_Flags::MASK) << 2; }
-+
-+
-+private:
-+    static List _free;
-+    static Page_Directory * _middle;
-+    static Page_Directory * _master;
-+    static const unsigned long RAM_BASE = Memory_Map::RAM_BASE;
-+};
- 
- __END_SYS
- 
-diff --git a/include/machine/riscv/sifive_u/sifive_u_memory_map.h b/include/machine/riscv/sifive_u/sifive_u_memory_map.h
-index e02d7bf..cca4450 100644
---- a/include/machine/riscv/sifive_u/sifive_u_memory_map.h
-+++ b/include/machine/riscv/sifive_u/sifive_u_memory_map.h
-@@ -24,6 +24,8 @@ public:
-         BOOT_STACK      = RAM_TOP + 1 - Traits<Machine>::STACK_SIZE, // will be used as the stack's base, not the stack pointer
-         FREE_BASE       = RAM_BASE,
-         FREE_TOP        = BOOT_STACK,
-+        PAGE_START      = 0xff7fffff + 1 - Traits<Machine>::STACK_SIZE - (1024+1) * 4 * 1024,
-+        MACHINE         = PAGE_START - 2 * 4096,
- 
-         // Memory-mapped devices
-         BIOS_BASE       = 0x00001000,   // BIOS ROM
-diff --git a/include/machine/riscv/sifive_u/sifive_u_traits.h b/include/machine/riscv/sifive_u/sifive_u_traits.h
-index 80c52a9..0c4962d 100644
---- a/include/machine/riscv/sifive_u/sifive_u_traits.h
-+++ b/include/machine/riscv/sifive_u/sifive_u_traits.h
-@@ -23,7 +23,8 @@ public:
-     static const unsigned int RAM_BASE          = 0x80000000;                           // 2 GB
-     static const unsigned int RAM_TOP           = 0x87ffffff;                           // 2 GB + 128 MB (max 1536 MB of RAM => RAM + MIO < 2 G)
-     static const unsigned int MIO_BASE          = 0x00000000;
--    static const unsigned int MIO_TOP           = 0x1fffffff;                           // 512 MB (max 512 MB of MIO => RAM + MIO < 2 G)
-+    static const unsigned int MIO_TOP           = 0x1fffffff;
-+    //static const unsigned int PAGE_TABLES       = 0x87f00000; // MEM_TOP - 16 MB                       // 512 MB (max 512 MB of MIO => RAM + MIO < 2 G)
- 
-     // Physical Memory at Boot
-     static const unsigned int BOOT              = NOT_USED;
-diff --git a/include/memory.h b/include/memory.h
-index f2a2031..dadc8f4 100644
---- a/include/memory.h
-+++ b/include/memory.h
-@@ -39,12 +39,13 @@ public:
-     typedef MMU::Flags Flags;
- 
- public:
--    Segment(unsigned int bytes, Flags flags = Flags::APP);
--    Segment(Phy_Addr phy_addr, unsigned int bytes, Flags flags);
-+    Segment(unsigned int bytes, const Flags & flags);
-+    //Segment(unsigned int bytes, Flags flags = Flags::APP);
-+    //Segment(Phy_Addr phy_addr, unsigned int bytes, Flags flags);
-     ~Segment();
- 
-     unsigned int size() const;
--    Phy_Addr phy_address() const;
-+    //Phy_Addr phy_address() const;
-     int resize(int amount);
- };
- 
-diff --git a/makedefs b/makedefs
-index 6d524ac..0fa445b 100644
---- a/makedefs
-+++ b/makedefs
-@@ -100,8 +100,8 @@ UUID		= $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g')
- ia32_COMP_PREFIX	:= /usr/bin/x86_64-linux-gnu-
- armv7_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
- armv8_COMP_PREFIX	:= /usr/bin/aarch64-linux-gnu-
--rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
--rv64_COMP_PREFIX	:= /usr/local/rv64/bin/riscv64-unknown-linux-gnu-
-+rv32_COMP_PREFIX	:= /home/haku/Documents/SO2/rv32/bin/riscv32-unknown-linux-gnu-
-+rv64_COMP_PREFIX	:= /home/haku/Documents/SO2/rv64/bin/riscv64-unknown-linux-gnu-
- COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
- 
- # Architecture specifics
-diff --git a/src/api/segment.cc b/src/api/segment.cc
-index d36882f..84520dc 100644
---- a/src/api/segment.cc
-+++ b/src/api/segment.cc
-@@ -5,17 +5,22 @@
- __BEGIN_SYS
- 
- // Methods
--Segment::Segment(unsigned int bytes, Flags flags): Chunk(bytes, flags, WHITE)
-+// Segment::Segment(unsigned int bytes, Flags flags): Chunk(bytes, flags, WHITE)
-+// {
-+//     db<Segment>(TRC) << "Segment(bytes=" << bytes << ",flags=" << flags << ") [Chunk::pt=" << Chunk::pt() << ",sz=" << Chunk::size() << "] => " << this << endl;
-+// }
-+//
-+//
-+// Segment::Segment(Phy_Addr phy_addr, unsigned int bytes, Flags flags): Chunk(phy_addr, bytes, flags | Flags::IO)
-+// // The MMU::IO flag signalizes the MMU that the attached memory shall
-+// // not be released when the chunk is deleted
-+// {
-+//     db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::pt=" << Chunk::pt() << ",sz=" << Chunk::size() << "] => " << this << endl;
-+// }
-+
-+Segment::Segment(unsigned int bytes, const Flags & flags): Chunk(bytes, flags)
- {
--    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",flags=" << flags << ") [Chunk::pt=" << Chunk::pt() << ",sz=" << Chunk::size() << "] => " << this << endl;
--}
--
--
--Segment::Segment(Phy_Addr phy_addr, unsigned int bytes, Flags flags): Chunk(phy_addr, bytes, flags | Flags::IO)
--// The MMU::IO flag signalizes the MMU that the attached memory shall
--// not be released when the chunk is deleted
--{
--    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::pt=" << Chunk::pt() << ",sz=" << Chunk::size() << "] => " << this << endl;
-+    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
- }
- 
- 
-@@ -31,10 +36,10 @@ unsigned int Segment::size() const
- }
- 
- 
--Segment::Phy_Addr Segment::phy_address() const
--{
--    return Chunk::phy_address();
--}
-+// Segment::Phy_Addr Segment::phy_address() const
-+// {
-+//     return Chunk::phy_address();
-+// }
- 
- 
- int Segment::resize(int amount)
-diff --git a/src/setup/setup_sifive_u.cc b/src/setup/setup_sifive_u.cc
-index d696048..468e36e 100644
---- a/src/setup/setup_sifive_u.cc
-+++ b/src/setup/setup_sifive_u.cc
-@@ -57,7 +57,7 @@ Setup::Setup()
-     Display::init();
-     kout << endl;
-     kerr << endl;
--    
-+
-     si = reinterpret_cast<System_Info *>(&__boot_time_system_info);
-     if(si->bm.n_cpus > Traits<Machine>::CPUS)
-         si->bm.n_cpus = Traits<Machine>::CPUS;
-@@ -134,6 +134,8 @@ void _entry() // machine mode
- 
-     Machine::clear_bss();
- 
-+
-+
-     CPU::mstatus(CPU::MPP_M);                           // stay in machine mode at mret
- 
-     CPU::mepc(CPU::Reg(&_setup));                       // entry = _setup
